var CircleSplit = function(t) {
    function e(n) {
        if (i[n]) return i[n].exports;
        var s = i[n] = {
            exports: {},
            id: n,
            loaded: !1
        };
        return t[n].call(s.exports, s, s.exports, e), s.loaded = !0, s.exports
    }
    var i = {};
    return e.m = t, e.c = i, e.p = "", e(0)
}([function(t, e, i) {
    function n(t, e, i) {
        return t > i.x - i.r && t < i.x + i.r && e > i.y - i.r && e < i.y + i.r
    }

    function s(t, e) {
        var i = {
            minDiameter: 2,
            size: "auto",
            imageCenterType: "contain",
            eventEnabled: !0
        };
        e || (e = {}), this.options = {};
        for (var n in i) null !== e[n] && void 0 !== e[n] ? this.options[n] = e[n] : this.options[n] = i[n];
        this.el = "object" == typeof t ? t : document.querySelector(t), "auto" === this.options.size && (this.options.size = Math.min(this.el.clientWidth, this.el.clientHeight)), this.canvasSize = this.options.size * a, this.circles = [], this.renderingCircles = [], this.maxLevel = 0, this.sourceCanvas = null, this.targetCanvas = null, this.sourceImage = null, this.pureColorContent = null, this.requestAnimationSeed = 0, this.moveEvent = "ontouchstart" in window ? "touchmove" : "mousemove", this.moveHandler = this._onMove.bind(this), this.rect = this.el.getBoundingClientRect(), this._init()
    }
    var r = i(1),
        a = 2;
    s.prototype = {
        constructor: s,
        _init: function() {
            this._createSourceCanvas(), this._createTargetCanvas(), this._render(), this._calMaxLevel(), this.options.eventEnabled && this.bindEvent()
        },
        _createSourceCanvas: function() {
            this.sourceCanvas = document.createElement("canvas"), this.sourceCanvas.width = this.canvasSize, this.sourceCanvas.height = this.canvasSize
        },
        _createTargetCanvas: function() {
            this.targetCanvas = document.createElement("canvas"), this.targetCanvas.width = this.canvasSize, this.targetCanvas.height = this.canvasSize, this.targetCanvas.style.width = this.targetCanvas.style.height = this.options.size + "px", this.el.appendChild(this.targetCanvas)
        },
        _drawSourceImage: function() {
            var t = this.canvasSize,
                e = new r({
                    containerWidth: t,
                    containerHeight: t,
                    originWidth: this.sourceImage.naturalWidth,
                    originHeight: this.sourceImage.naturalHeight,
                    centerType: this.options.imageCenterType
                }),
                i = this.sourceCanvas.getContext("2d");
            i.clearRect(0, 0, t, t), i.drawImage(this.sourceImage, e.offset().left, e.offset().top, e.width(), e.height())
        },
        _drawCircle: function(t, e) {
        	// e: 是否已经存在circle
            var i = this.targetCanvas.getContext("2d"),
                n = this.circles[t.index], // circle
                s = t.x, // x
                r = t.y, // y
                a = t.r; // r
            e ? (n.x = t.x, n.y = t.y, n.r = t.r, n.level = t.level, n.px = t.px, n.py = t.py) : this.circles.push({
                x: s,
                y: r,
                r: a,
                level: t.level,
                px: t.px,
                py: t.py
            }), i.fillStyle = this._getPixelRGBColor(s, r), i.beginPath(), i.arc(s, r, a, 0, 2 * Math.PI), i.closePath(), i.fill()
        },
        _onMove: function(t) {
            var e = "ontouchstart" in window,
                i = this.rect;
            e ? this._tagCircle((t.touches[0].pageX - i.left) * a, (t.touches[0].pageY - i.top) * a) : this._tagCircle(t.offsetX * a, t.offsetY * a), t.preventDefault(), t.stopPropagation()
        },
        _calMaxLevel: function() {
            for (var t = 1, e = this.canvasSize / 2, i = this.options.minDiameter * a; e >= i;) e /= 2, t++;
            this.maxLevel = t
        },
        _tagCircle: function(t, e, i) {
            var n = this.findCircle(t, e),
                s = this.circles[n];
            i && i <= s.level || s && (i = i ? Math.min(i, this.maxLevel) : Math.min(s.level + 1, this.maxLevel), this.renderingCircles.push({
                x: s.x,
                y: s.y,
                r: s.r,
                index: n,
                level: s.level,
                targetLevel: i
            }))
        },
        _getPixelRGBColor: function(t, e) {
            var i = null;
            // t:x e:y
            // return rgb(xxx);
            return this.pureColorContent ? this.pureColorContent : (i = this.sourceCanvas.getContext("2d").getImageData(parseInt(t), parseInt(e), 1, 1).data, "rgb(" + i[0] + "," + i[1] + "," + i[2] + ")")
        },
        _splitCircle: function(t) {
            var e = this.targetCanvas.getContext("2d"),
                i = t.targetLevel - t.level,
                n = t.r / Math.pow(2, i), // n = t.r / 2^i
                s = t.r / n, // s = t.r / n = t.r * 2^i
                r = t.y - t.r, // r = t.y - t.r
                a = t.x - t.r; // a = t.x - t.r
            e.clearRect(a, r, 2 * t.r, 2 * t.r);
            for (var h = 0; h < s; h++)
                for (var o = 0; o < s; o++) this._drawCircle({
                    x: a + 2 * o * n + n,
                    y: r + 2 * h * n + n,
                    r: n,
                    index: t.index,
                    level: t.targetLevel,
                    px: t.x,
                    py: t.y
                }, 0 === h && 0 === o)
        },
        _render: function() {
            for (var t, e = this.maxLevel, i = this.renderingCircles; t = i.pop();) t.level <= e && this._splitCircle(t);
            this.requestAnimationSeed = requestAnimationFrame(this._render.bind(this))
        },
        _resetCanvas: function(t) {
            t.getContext("2d").clearRect(0, 0, this.canvasSize, this.canvasSize)
        },
        bindEvent: function() {
            this.targetCanvas.addEventListener(this.moveEvent, this.moveHandler)
        },
        unbindEvent: function() {
            this.targetCanvas.removeEventListener(this.moveEvent, this.moveHandler)
        },
        findCircle: function(t, e) {
            var i, s = this.circles,
                r = null;
            for (i = 0; i < s.length && (r = s[i], !n(t, e, r)); i++);
            return i === s.length ? -1 : i
        },
        setColor: function(t) {
        	console.log("setColor:",t);
            this.pureColorContent = t, this.sourceImage = null, this.circles = [], this._resetCanvas(this.targetCanvas), this._drawCircle({
                x: this.targetCanvas.width / 2,
                y: this.targetCanvas.height / 2,
                r: this.canvasSize / 2,
                level: 1,
                px: null,
                py: null
            })
        },
        setImage: function(t) {
            this.circles = [], this.pureColorContent = null, this._resetCanvas(this.targetCanvas), "string" == typeof t ? (this.sourceImage = new Image, t.startsWith("data:image") || (this.sourceImage.crossOrigin = "anonymous"), this.sourceImage.onload = function() {
                this._drawSourceImage(), this._drawCircle({
                    x: this.targetCanvas.width / 2,
                    y: this.targetCanvas.height / 2,
                    r: this.canvasSize / 2,
                    level: 1,
                    px: null,
                    py: null
                })
            }.bind(this), this.sourceImage.src = t) : (this.sourceImage = t, this._drawSourceImage(), this._drawCircle({
                x: this.targetCanvas.width / 2,
                y: this.targetCanvas.height / 2,
                r: this.canvasSize / 2,
                level: 1,
                px: null,
                py: null
            }))
        },
        setMinDiameter: function(t) {
            this.options.minDiameter = t, this._calMaxLevel()
        },
        split: function() {
            var t = (this.options.minDiameter * a, this.maxLevel),
                e = arguments;
            e.length > 1 ? this._tagCircle(e[0], e[1], e[2]) : 1 === e.length ? (this.circles = [{
                x: this.targetCanvas.width / 2,
                y: this.targetCanvas.height / 2,
                r: this.canvasSize / 2,
                level: 1
            }], this.renderingCircles = [{
                x: this.circles[0].x,
                y: this.circles[0].y,
                r: this.circles[0].r,
                index: 0,
                level: this.circles[0].level,
                targetLevel: Math.min(e[0], t)
            }]) : (this.renderingCircles = [], this.circles.forEach(function(e, i) {
                e.level <= t && this.renderingCircles.push({
                    x: e.x,
                    y: e.y,
                    r: e.r,
                    index: i,
                    level: e.level,
                    targetLevel: Math.min(e.level + 1, t)
                })
            }, this))
        },
        merge: function() {
            return void console.warn("not implemented")
        },
        getLevel: function(t) {
            return Math.log2(this.canvasSize / ("object" == typeof t ? t.r : t))
        },
        destroy: function() {
            cancelAnimationFrame(this.requestAnimationSeed), this.unbindEvent(), this.sourceCanvas = null, this.targetCanvas = null, this.sourceImage = null, this.pureColorContent = null, this.circles = [], this.renderingCircles = []
        }
    }, t.exports = s
}, function(t, e, i) {
    ! function(e, i) {
        t.exports = i()
    }(this, function() {
        "use strict";

        function t(t) {
            t = t || {}, this.options = {
                containerWidth: 100,
                containerHeight: 100,
                originWidth: 100,
                originHeight: 100,
                centerType: "cover"
            };
            for (var e in this.options) void 0 !== t[e] && (this.options[e] = t[e]);
            this._ratio = 1, this._newWidth = 0, this._newHeight = 0, this._offset = {
                top: 0,
                left: 0
            }, "cover" === this.options.centerType ? this._coverCenter() : this._containCenter()
        }
        return t.prototype = {
            constructor: t,
            _coverCenter: function() {
                var t = this.options.originWidth,
                    e = this.options.originHeight,
                    i = this.options.containerWidth,
                    n = this.options.containerHeight,
                    s = t / e,
                    r = i / n,
                    a = 1;
                s > r ? (a = n / e, this._newWidth = t * a, this._newHeight = e * a, this._offset = {
                    top: 0,
                    left: (this._newWidth - i) / -2
                }) : s < r ? (a = i / t, this._newWidth = t * a, this._newHeight = e * a, this._offset = {
                    top: (this._newHeight - n) / -2,
                    left: 0
                }) : (a = i / t, this._newWidth = t * a, this._newHeight = e * a, this._offset = {
                    top: 0,
                    left: 0
                }), this._ratio = a
            },
            _containCenter: function() {
                var t = this.options.originWidth,
                    e = this.options.originHeight,
                    i = this.options.containerWidth,
                    n = this.options.containerHeight,
                    s = t / e,
                    r = i / n,
                    a = 1;
                s > r ? (a = i / t, this._newWidth = t * a, this._newHeight = e * a, this._offset = {
                    top: (this._newHeight - n) / -2,
                    left: 0
                }) : s < r ? (a = n / e, this._newWidth = t * a, this._newHeight = e * a, this._offset = {
                    top: 0,
                    left: (this._newWidth - i) / -2
                }) : (a = i / t, this._newWidth = t * a, this._newHeight = e * a, this._offset = {
                    top: 0,
                    left: 0
                }), this._ratio = a
            },
            ratio: function() {
                return this._ratio
            },
            width: function() {
                return this._newWidth
            },
            height: function() {
                return this._newHeight
            },
            offset: function() {
                return this._offset
            }
        }, t
    })
}]);